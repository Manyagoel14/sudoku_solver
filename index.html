<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sudoku Solver</title>

    <!-- React + Babel + Tailwind -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">

        const { useState, useEffect } = React;

        const SudokuSolver = () => {

            // ------------------ STATES ------------------
            const emptyGrid = () => Array(9).fill().map(() => Array(9).fill(0));
            const [grid, setGrid] = useState(emptyGrid());
            const [originalGrid, setOriginalGrid] = useState(emptyGrid());
            const [solved, setSolved] = useState(false);
            const [solving, setSolving] = useState(false);
            const [visualizing, setVisualizing] = useState(false);
            const [selectedCell, setSelectedCell] = useState(null);

            // TIMER
            const [time, setTime] = useState(0);
            const [running, setRunning] = useState(true);

            // start timer on load
            useEffect(() => {
                let interval = null;
                if (running) {
                    interval = setInterval(() => setTime(prev => prev + 1), 1000);
                }
                return () => clearInterval(interval);
            }, [running]);

            const sleep = (ms) => new Promise(res => setTimeout(res, ms));


            // ------------------ SOLVE (NORMAL) ------------------
            const handleSolve = async () => {
                setSolving(true);
                try {
                    const res = await fetch("http://localhost:5000/solve", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ grid })
                    });
                    const data = await res.json();

                    if (data.solution) {
                        setOriginalGrid(grid.map(r => [...r]));
                        setGrid(data.solution);
                        setSolved(true);
                        setRunning(false);   // STOP TIMER
                    } else {
                        alert("No solution found!");
                    }
                } catch {
                    alert("Backend error");
                }
                setSolving(false);
            };


            // ------------------ VISUALIZE SOLVING ------------------
            const visualizeSolve = async () => {
                setVisualizing(true);
                try {
                    const res = await fetch("http://localhost:5000/solve", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ grid })
                    });

                    const data = await res.json();
                    if (!data.steps) return alert("Error getting steps.");

                    let board = grid.map(r => [...r]);

                    for (let s of data.steps) {
                        board[s.row][s.col] = s.value;
                        setGrid(board.map(r => [...r]));
                        await sleep(25);
                    }

                    setSolved(true);
                    setRunning(false);  // STOP TIMER
                } catch {
                    alert("Error");
                }
                setVisualizing(false);
            };


            // ------------------ LOAD RANDOM PUZZLE ------------------
            const loadExample = async () => {
                try {
                    const res = await fetch("http://localhost:5000/generate");
                    const data = await res.json();

                    setGrid(data.puzzle);
                    setOriginalGrid(data.puzzle.map(r => [...r]));
                    setSolved(false);
                    setTime(0);
                    setRunning(true);
                } catch {
                    alert("Backend error");
                }
            };


            // ------------------ CLEAR GRID ------------------
            const handleClear = () => {
                setGrid(emptyGrid());
                setOriginalGrid(emptyGrid());
                setSolved(false);
                setTime(0);
                setRunning(true);
            };


            // ------------------ USER INPUT ------------------
            const handleCellChange = (r, c, value) => {
                if (solved || visualizing) return;

                const val = parseInt(value) || 0;
                if (val < 0 || val > 9) return;

                const newGrid = grid.map(row => [...row]);
                newGrid[r][c] = val;
                setGrid(newGrid);
            };


            // ------------------ COLOR LOGIC ------------------
            const isOriginal = (r, c) => originalGrid[r][c] !== 0;
            const isSolverInserted = (r, c) => !isOriginal(r, c) && grid[r][c] !== 0;


            // ------------------ TIMER FORMAT ------------------
            const formatTime = (t) => {
                const m = Math.floor(t / 60);
                const s = t % 60;
                return `${m}:${s.toString().padStart(2, "0")}`;
            };


            // ------------------ UI ------------------
            return (
                <div className="min-h-screen bg-gradient-to-br from-purple-600 to-indigo-700 p-6">

                    {/* HEADER */}
                    <div className="text-center text-white mb-6">
                        <h1 className="text-5xl font-bold">Sudoku Solver</h1>
                        <p className="text-xl mt-2">Backtracking + Visualization</p>
                        <p className="text-2xl mt-3 font-mono">‚è± Time: {formatTime(time)}</p>
                    </div>


                    {/* BOARD */}
                    <div className="max-w-xl mx-auto bg-white p-5 rounded-2xl shadow-2xl">
                        <div className="grid grid-cols-9 gap-0 bg-gray-300 p-2 rounded-xl">

                            {grid.map((row, r) => (
                                row.map((cell, c) => {

                                    const thickRight = (c === 2 || c === 5) ? "border-r-4 border-black" : "";
                                    const thickBottom = (r === 2 || r === 5) ? "border-b-4 border-black" : "";

                                    return (
                                        <input
                                            key={r + "-" + c}
                                            value={cell === 0 ? "" : cell}
                                            maxLength="1"
                                            disabled={solving || visualizing}
                                            onChange={(e) => handleCellChange(r, c, e.target.value)}
                                            className={`
                                                w-10 h-10 sm:w-12 sm:h-12 text-center text-xl bg-white outline-none

                                                border border-gray-400

                                                ${c === 2 || c === 5 ? "border-r-4 border-black" : ""}
                                                ${r === 2 || r === 5 ? "border-b-4 border-black" : ""}

                                                ${isOriginal(r, c) ? "text-blue-700 font-bold" : ""}
                                                ${isSolverInserted(r, c) ? "text-green-600 font-bold" : ""}
                                            `}
                                        />

                                    );
                                })
                            ))}

                        </div>


                        {/* BUTTONS */}
                        <div className="grid grid-cols-1 sm:grid-cols-4 gap-3 mt-6">
                            <button
                                onClick={handleSolve}
                                className="bg-green-600 text-white py-3 rounded-xl font-bold hover:bg-green-700">
                                Solve
                            </button>

                            <button
                                onClick={visualizeSolve}
                                className="bg-blue-600 text-white py-3 rounded-xl font-bold hover:bg-blue-700">
                                Visualize
                            </button>

                            <button
                                onClick={loadExample}
                                className="bg-amber-500 text-white py-3 rounded-xl font-bold hover:bg-amber-600">
                                Load Random
                            </button>

                            <button
                                onClick={handleClear}
                                className="bg-red-600 text-white py-3 rounded-xl font-bold hover:bg-red-700">
                                Clear
                            </button>
                        </div>

                    </div>

                </div>
            );
        };

        ReactDOM.render(<SudokuSolver />, document.getElementById("root"));
    </script>

</body>

</html>